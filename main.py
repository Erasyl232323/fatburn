"""
FitPulse — Desktop app (Python + tkinter)
Single-file application: app.py
Features:
- Modern-ish tkinter UI (custom styling using ttk themes)
- Tabs: Auth (login/register), Activity (activity level), BMI (calculator, save/load, export, logout)
- SQLite database for user credentials and saved profiles
- JSON save/load of configurations
- Units support, gender selection, validation
- BMI calculation, category, textual recommendations
- Graphical indicator (Canvas)
- Export report to TXT

Notes:
- Tested with Python 3.8+ and tkinter
- Requires no external libraries

Author: Generated by assistant
"""

import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import sqlite3
import ttkbootstrap
import hashlib
import json
import os
from datetime import datetime
import math
import sys

# -----------------------------
# Constants and helpers
# -----------------------------
DB_FILENAME = 'fatburn_users.db'
CONFIG_DIR = 'fatburn_configs'
REPORTS_DIR = 'fatburn_reports'

if not os.path.isdir(CONFIG_DIR):
    os.makedirs(CONFIG_DIR, exist_ok=True)
if not os.path.isdir(REPORTS_DIR):
    os.makedirs(REPORTS_DIR, exist_ok=True)

BMI_CATEGORIES = [
    (0, 16.0, 'Выраженный дефицит массы тела'),
    (16.0, 18.5, 'Недостаток массы тела'),
    (18.5, 25.0, 'Норма'),
    (25.0, 30.0, 'Избыточная масса тела (предожирение)'),
    (30.0, 35.0, 'Ожирение I степени'),
    (35.0, 40.0, 'Ожирение II степени'),
    (40.0, 999.0, 'Ожирение III степени')
]

ACTIVITY_LEVELS = {
    'Малоподвижная': 1.2,
    'Низкая активность': 1.375,
    'Умеренная активность': 1.55,
    'Высокая активность': 1.725,
    'Очень высокая': 1.9
}

UNIT_OPTIONS = ['Metric (m, kg)', 'Metric (cm, kg)', 'Imperial (ft/in, lb)']
GENDER_OPTIONS = ['Мужской', 'Женский', 'Другое']

# -----------------------------
# Database helpers
# -----------------------------
class DB:
    def __init__(self, filename=DB_FILENAME):
        self.filename = filename
        self.conn = sqlite3.connect(self.filename)
        self._create_tables()

    def _create_tables(self):
        c = self.conn.cursor()
        c.execute('''
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                username TEXT UNIQUE NOT NULL,
                password_hash TEXT NOT NULL,
                created_at TEXT NOT NULL
            )
        ''')
        c.execute('''
            CREATE TABLE IF NOT EXISTS profiles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                name TEXT,
                data TEXT,
                saved_at TEXT,
                FOREIGN KEY(user_id) REFERENCES users(id)
            )
        ''')
        self.conn.commit()

    def create_user(self, username, password):
        h = hashlib.sha256(password.encode('utf-8')).hexdigest()
        try:
            c = self.conn.cursor()
            c.execute('INSERT INTO users (username, password_hash, created_at) VALUES (?, ?, ?)',
                      (username, h, datetime.utcnow().isoformat()))
            self.conn.commit()
            return True, None
        except sqlite3.IntegrityError as e:
            return False, str(e)

    def verify_user(self, username, password):
        h = hashlib.sha256(password.encode('utf-8')).hexdigest()
        c = self.conn.cursor()
        c.execute('SELECT id FROM users WHERE username=? AND password_hash=?', (username, h))
        row = c.fetchone()
        if row:
            return True, row[0]
        return False, None

    def save_profile(self, user_id, name, data_dict):
        j = json.dumps(data_dict, ensure_ascii=False)
        c = self.conn.cursor()
        c.execute('INSERT INTO profiles (user_id, name, data, saved_at) VALUES (?, ?, ?, ?)',
                  (user_id, name, j, datetime.utcnow().isoformat()))
        self.conn.commit()

    def list_profiles(self, user_id):
        c = self.conn.cursor()
        c.execute('SELECT id, name, saved_at FROM profiles WHERE user_id=? ORDER BY saved_at DESC', (user_id,))
        return c.fetchall()

    def load_profile(self, profile_id):
        c = self.conn.cursor()
        c.execute('SELECT data FROM profiles WHERE id=?', (profile_id,))
        r = c.fetchone()
        if r:
            return json.loads(r[0])
        return None

# -----------------------------
# Utility functions
# -----------------------------

def clamp(v, a, b):
    return max(a, min(b, v))


def bmi_category(bmi):
    for lo, hi, label in BMI_CATEGORIES:
        if lo <= bmi < hi:
            return label
    return 'Неизвестно'


def pretty_bmi_recommendation(category):
    # Basic recommendations; could be extended
    mapping = {
        'Выраженный дефицит массы тела': 'Нужно срочно скорректировать питание и обратиться к врачу.',
        'Недостаток массы тела': 'Рекомендуется увеличить калорийность рациона, добавить силовые тренировки.',
        'Норма': 'Отлично! Поддерживайте активность и сбалансированное питание.',
        'Избыточная масса тела (предожирение)': 'Снизьте калорийность, увеличьте физическую активность.',
        'Ожирение I степени': 'Проконсультируйтесь с врачом и нутрициологом для плана похудения.',
        'Ожирение II степени': 'Необходимо медицинское наблюдение и индивидуальная программа снижения массы.',
        'Ожирение III степени': 'Требуется неотложная медицинская помощь и длительная терапия.'
    }
    return mapping.get(category, '')

# -----------------------------
# Main Application
# -----------------------------
class fatburnApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title('fatburn — BMI App')
        self.geometry('980x680')
        self.minsize(900, 600)

        # Styling
        self.style = ttk.Style(self)
        # try to use a modern theme if available
        available = self.style.theme_names()
        # prefer clam, alt, or default to classic
        chosen = 'clam' if 'clam' in available else available[0]
        try:
            self.style.theme_use(chosen)
        except Exception:
            pass

        # DB
        self.db = DB()

        # session
        self.current_user_id = None
        self.current_username = None

        # notebook
        self.notebook = ttk.Notebook(self)
        self.notebook.pack(fill='both', expand=True, padx=12, pady=12)

        # Frames
        self.auth_frame = AuthFrame(self.notebook, app=self)
        self.activity_frame = ActivityFrame(self.notebook, app=self)
        self.bmi_frame = BMIFrame(self.notebook, app=self)

        self.notebook.add(self.auth_frame, text='Вход / Регистрация')
        self.notebook.add(self.activity_frame, text='Активность')
        self.notebook.add(self.bmi_frame, text='BMI')

        # Bind tab change to ensure only logged in users can access some tabs
        self.notebook.bind('<<NotebookTabChanged>>', self.on_tab_change)

    def login(self, user_id, username):
        self.current_user_id = user_id
        self.current_username = username
        # update frames
        self.activity_frame.on_login(user_id, username)
        self.bmi_frame.on_login(user_id, username)
        # switch to BMI tab on successful login
        self.notebook.select(self.bmi_frame)

    def logout(self):
        # reset session
        self.current_user_id = None
        self.current_username = None
        self.activity_frame.on_logout()
        self.bmi_frame.on_logout()
        # go to auth tab
        self.notebook.select(self.auth_frame)

    def on_tab_change(self, event=None):
        tab = event.widget.select()
        frame = event.widget.nametowidget(tab)
        # if user not logged in, restrict to auth tab
        if self.current_user_id is None and frame not in (self.auth_frame,):
            messagebox.showinfo('Требуется вход', 'Пожалуйста, войдите в систему или зарегистрируйтесь.')
            self.notebook.select(self.auth_frame)

# -----------------------------
# Authentication Frame
# -----------------------------
class AuthFrame(ttk.Frame):
    def __init__(self, parent, app: fatburnApp):
        super().__init__(parent)
        self.app = app
        self._build_ui()

    def _build_ui(self):
        # layout: left box with forms, right box with tips
        left = ttk.Frame(self)
        left.pack(side='left', fill='both', expand=True, padx=(10, 6), pady=10)
        right = ttk.Frame(self)
        right.pack(side='right', fill='y', padx=(6, 10), pady=10)

        # Notebook inside left for login/register
        sub_nb = ttk.Notebook(left)
        sub_nb.pack(fill='both', expand=True)

        login_frame = ttk.Frame(sub_nb, padding=12)
        register_frame = ttk.Frame(sub_nb, padding=12)

        sub_nb.add(login_frame, text='Вход')
        sub_nb.add(register_frame, text='Регистрация')

        # --- Login ---
        ttk.Label(login_frame, text='Имя пользователя:').grid(row=0, column=0, sticky='w')
        self.login_user = ttk.Entry(login_frame)
        self.login_user.grid(row=0, column=1, sticky='ew', padx=6, pady=6)

        ttk.Label(login_frame, text='Пароль:').grid(row=1, column=0, sticky='w')
        self.login_pass = ttk.Entry(login_frame, show='*')
        self.login_pass.grid(row=1, column=1, sticky='ew', padx=6, pady=6)

        login_frame.columnconfigure(1, weight=1)

        btn_login = ttk.Button(login_frame, text='Войти', command=self._on_login)
        btn_login.grid(row=2, column=0, columnspan=2, pady=(8, 0))

        # Quick demo credentials
        ttk.Label(login_frame, text='(demo: user / pass)').grid(row=3, column=0, columnspan=2, pady=(6, 0))

        # --- Register ---
        ttk.Label(register_frame, text='Имя пользователя:').grid(row=0, column=0, sticky='w')
        self.reg_user = ttk.Entry(register_frame)
        self.reg_user.grid(row=0, column=1, sticky='ew', padx=6, pady=6)

        ttk.Label(register_frame, text='Пароль:').grid(row=1, column=0, sticky='w')
        self.reg_pass = ttk.Entry(register_frame, show='*')
        self.reg_pass.grid(row=1, column=1, sticky='ew', padx=6, pady=6)

        ttk.Label(register_frame, text='Подтвердите пароль:').grid(row=2, column=0, sticky='w')
        self.reg_pass2 = ttk.Entry(register_frame, show='*')
        self.reg_pass2.grid(row=2, column=1, sticky='ew', padx=6, pady=6)

        register_frame.columnconfigure(1, weight=1)

        btn_reg = ttk.Button(register_frame, text='Зарегистрироваться', command=self._on_register)
        btn_reg.grid(row=3, column=0, columnspan=2, pady=(8, 0))

        # Right side: info
        ttk.Label(right, text='Советы по использованию', font=('Helvetica', 12, 'bold')).pack(anchor='n')
        tips = tk.Text(right, width=36, height=20, wrap='word')
        tips.insert('1.0', (
            '1) Зарегистрируйтесь и создайте профиль пользователя.\n\n'
            '2) Перейдите на вкладку «Активность» и выберите уровень активности.\n\n'
            '3) На вкладке BMI введите вес и рост, выберите единицы измерения и рассчитайте ИМТ.\n\n'
            '4) Сохраните конфигурацию в JSON или экспортируйте отчет в текстовый файл.\n\n'
            '5) Нажмите «Выйти из аккаунта», чтобы завершить сессию.'
        ))
        tips.config(state='disabled')
        tips.pack(fill='both', expand=True, pady=(8, 0))

        # Demo user creation for convenience
        self._ensure_demo_user()

    def _ensure_demo_user(self):
        # create a demo user if not exists
        ok, _ = self.app.db.create_user('user', 'pass')
        # ignore errors

    def _on_login(self):
        username = self.login_user.get().strip()
        password = self.login_pass.get().strip()
        if not username or not password:
            messagebox.showerror('Ошибка', 'Введите имя пользователя и пароль')
            return
        ok, user_id = self.app.db.verify_user(username, password)
        if ok:
            messagebox.showinfo('Успешно', f'Вход выполнен: {username}')
            self.app.login(user_id, username)
        else:
            messagebox.showerror('Ошибка', 'Неверное имя пользователя или пароль')

    def _on_register(self):
        username = self.reg_user.get().strip()
        p1 = self.reg_pass.get().strip()
        p2 = self.reg_pass2.get().strip()
        if not username or not p1 or not p2:
            messagebox.showerror('Ошибка', 'Пожалуйста, заполните все поля')
            return
        if p1 != p2:
            messagebox.showerror('Ошибка', 'Пароли не совпадают')
            return
        ok, err = self.app.db.create_user(username, p1)
        if ok:
            messagebox.showinfo('Готово', 'Пользователь создан. Теперь войдите.')
            self.reg_user.delete(0, 'end')
            self.reg_pass.delete(0, 'end')
            self.reg_pass2.delete(0, 'end')
        else:
            messagebox.showerror('Ошибка', f'Не удалось создать пользователя: {err}')

# -----------------------------
# Activity Frame
# -----------------------------
class ActivityFrame(ttk.Frame):
    def __init__(self, parent, app: fatburnApp):
        super().__init__(parent)
        self.app = app
        self.selected_level = tk.StringVar(value='Малоподвижная')
        self.user_id = None
        self.username = None
        self._build_ui()

    def _build_ui(self):
        container = ttk.Frame(self, padding=12)
        container.pack(fill='both', expand=True)

        top = ttk.Label(container, text='Выберите уровень физической активности', font=('Helvetica', 14, 'bold'))
        top.pack(anchor='w')

        # radio options
        radio_frame = ttk.Frame(container)
        radio_frame.pack(fill='x', pady=8)

        for i, key in enumerate(ACTIVITY_LEVELS.keys()):
            r = ttk.Radiobutton(radio_frame, text=key, value=key, variable=self.selected_level, command=self._on_select)
            r.grid(row=i//2, column=i%2, sticky='w', padx=6, pady=4)

        # description box
        self.desc = tk.Text(container, height=8, wrap='word')
        self.desc.pack(fill='x', pady=(6, 12))
        self.desc.insert('1.0', self._describe(self.selected_level.get()))
        self.desc.config(state='disabled')

        btn_frame = ttk.Frame(container)
        btn_frame.pack(fill='x')

        self.save_btn = ttk.Button(btn_frame, text='Сохранить уровень активности в профиль', command=self._save_activity)
        self.save_btn.pack(side='left')

        self.load_btn = ttk.Button(btn_frame, text='Загрузить последнюю конфигурацию', command=self._load_last)
        self.load_btn.pack(side='left', padx=8)

        # profile list
        prof_frame = ttk.LabelFrame(container, text='Сохранённые профили (последние 10)')
        prof_frame.pack(fill='both', expand=True, pady=(12, 0))

        self.profiles_list = ttk.Treeview(prof_frame, columns=('id', 'name', 'saved_at'), show='headings')
        self.profiles_list.heading('id', text='ID')
        self.profiles_list.heading('name', text='Имя')
        self.profiles_list.heading('saved_at', text='Сохранено')
        self.profiles_list.column('id', width=40)
        self.profiles_list.column('name', width=200)
        self.profiles_list.column('saved_at', width=160)
        self.profiles_list.pack(fill='both', expand=True)

        # double click to load
        self.profiles_list.bind('<Double-1>', self._on_profile_double)

    def _on_select(self):
        self.desc.config(state='normal')
        self.desc.delete('1.0', 'end')
        self.desc.insert('1.0', self._describe(self.selected_level.get()))
        self.desc.config(state='disabled')

    def _describe(self, key):
        val = ACTIVITY_LEVELS.get(key, 1.2)
        return f'Уровень: {key}\nКоэффициент активности: {val}\n\n' + (
            'Малоподвижная — минимальная активность, в основном сидячая работа.\n' 
            'Низкая — небольшой объем упражнений 1-3 раза в неделю.\n'
            'Умеренная — регулярные тренировки 3-5 раз в неделю.\n'
            'Высокая — интенсивные тренировки 6-7 раз/нед.\n'
            'Очень высокая — физическая работа или интенсивная подготовка.'
        )

    def _save_activity(self):
        if self.user_id is None:
            messagebox.showerror('Ошибка', 'Пожалуйста, войдите в систему, чтобы сохранять профили.')
            return
        name = f'activity_{datetime.utcnow().strftime("%Y%m%d_%H%M%S")}'
        data = {
            'activity_level': self.selected_level.get(),
            'activity_coeff': ACTIVITY_LEVELS.get(self.selected_level.get(), 1.2)
        }
        self.app.db.save_profile(self.user_id, name, data)
        messagebox.showinfo('Сохранено', 'Уровень активности сохранён в профиль')
        self._refresh_profiles()

    def _load_last(self):
        # load last profile and apply if contains activity
        if self.user_id is None:
            messagebox.showerror('Ошибка', 'Пожалуйста, войдите в систему.')
            return
        rows = self.app.db.list_profiles(self.user_id)
        if not rows:
            messagebox.showinfo('Пусто', 'Нет сохранённых профилей')
            return
        last_id = rows[0][0]
        data = self.app.db.load_profile(last_id)
        if data and 'activity_level' in data:
            self.selected_level.set(data['activity_level'])
            self._on_select()
            messagebox.showinfo('Загружено', 'Последняя конфигурация активности загружена')
        else:
            messagebox.showwarning('Формат', 'В выбранном профиле нет данных об активности')

    def _refresh_profiles(self):
        for i in self.profiles_list.get_children():
            self.profiles_list.delete(i)
        if self.user_id is None:
            return
        rows = self.app.db.list_profiles(self.user_id)
        for r in rows[:10]:
            self.profiles_list.insert('', 'end', values=r)

    def _on_profile_double(self, event):
        sel = self.profiles_list.selection()
        if not sel:
            return
        item = self.profiles_list.item(sel[0])
        profile_id = item['values'][0]
        data = self.app.db.load_profile(profile_id)
        if data and 'activity_level' in data:
            self.selected_level.set(data['activity_level'])
            self._on_select()
            messagebox.showinfo('Загружено', f'Профиль {item["values"][1]} загружен')
        else:
            messagebox.showwarning('Формат', 'В выбранном профиле нет данных об активности')

    def on_login(self, user_id, username):
        self.user_id = user_id
        self.username = username
        self._refresh_profiles()

    def on_logout(self):
        self.user_id = None
        self.username = None
        self.profiles_list.delete(*self.profiles_list.get_children())

# -----------------------------
# BMI Frame
# -----------------------------
class BMIFrame(ttk.Frame):
    def __init__(self, parent, app: fatburnApp):
        super().__init__(parent)
        self.app = app
        self.user_id = None
        self.username = None
        self.unit_var = tk.StringVar(value=UNIT_OPTIONS[1])
        self.gender_var = tk.StringVar(value=GENDER_OPTIONS[0])
        self.age_var = tk.IntVar(value=30)
        self.height_var = tk.DoubleVar(value=170.0)
        self.weight_var = tk.DoubleVar(value=70.0)
        self.imt_value = tk.DoubleVar(value=0.0)
        self._build_ui()

    def _build_ui(self):
        container = ttk.Frame(self, padding=12)
        container.pack(fill='both', expand=True)

        top = ttk.Frame(container)
        top.pack(fill='x')

        form = ttk.Frame(top)
        form.pack(side='left', fill='both', expand=True)

        # Units
        ttk.Label(form, text='Единицы измерения:').grid(row=0, column=0, sticky='w')
        self.units_cb = ttk.Combobox(form, values=UNIT_OPTIONS, state='readonly', textvariable=self.unit_var)
        self.units_cb.grid(row=0, column=1, sticky='w', padx=6, pady=6)
        self.units_cb.bind('<<ComboboxSelected>>', self._on_units_change)

        # Gender
        ttk.Label(form, text='Пол:').grid(row=1, column=0, sticky='w')
        self.gender_cb = ttk.Combobox(form, values=GENDER_OPTIONS, state='readonly', textvariable=self.gender_var)
        self.gender_cb.grid(row=1, column=1, sticky='w', padx=6, pady=6)

        # Age
        ttk.Label(form, text='Возраст:').grid(row=2, column=0, sticky='w')
        self.age_entry = ttk.Entry(form, textvariable=self.age_var)
        self.age_entry.grid(row=2, column=1, sticky='w', padx=6, pady=6)

        # Height
        self.h_label = ttk.Label(form, text='Рост (см):')
        self.h_label.grid(row=3, column=0, sticky='w')
        self.h_entry = ttk.Entry(form, textvariable=self.height_var)
        self.h_entry.grid(row=3, column=1, sticky='w', padx=6, pady=6)

        # Weight
        ttk.Label(form, text='Вес (кг):').grid(row=4, column=0, sticky='w')
        self.w_entry = ttk.Entry(form, textvariable=self.weight_var)
        self.w_entry.grid(row=4, column=1, sticky='w', padx=6, pady=6)

        # Buttons
        btn_frame = ttk.Frame(form)
        btn_frame.grid(row=5, column=0, columnspan=2, pady=(10, 0))

        calc_btn = ttk.Button(btn_frame, text='Рассчитать ИМТ', command=self.calculate_bmi)
        calc_btn.pack(side='left')

        save_btn = ttk.Button(btn_frame, text='Сохранить конфигурацию (JSON)', command=self.save_config)
        save_btn.pack(side='left', padx=6)

        load_btn = ttk.Button(btn_frame, text='Загрузить конфигурацию', command=self.load_config)
        load_btn.pack(side='left')

        export_btn = ttk.Button(btn_frame, text='Экспорт отчёта', command=self.export_report)
        export_btn.pack(side='left', padx=6)

        # Logout button
        logout_btn = ttk.Button(form, text='Выйти из аккаунта', command=self._on_logout)
        logout_btn.grid(row=6, column=0, columnspan=2, pady=(12, 0))

        # Visualization canvas
        vis = ttk.LabelFrame(container, text='Графическое отображение')
        vis.pack(side='right', fill='both', expand=True, padx=(8, 0))

        self.canvas = tk.Canvas(vis, width=420, height=420, bg='white')
        self.canvas.pack(fill='both', expand=True, padx=8, pady=8)

        # text panel with result
        self.result_text = tk.Text(container, width=40, height=8, wrap='word')
        self.result_text.pack(side='left', fill='y', padx=(6, 0))
        self.result_text.insert('1.0', 'Результат ИМТ будет здесь')
        self.result_text.config(state='disabled')

        # initial draw
        self._draw_canvas(0)

    def _on_units_change(self, event=None):
        u = self.unit_var.get()
        if 'cm' in u:
            self.h_label.config(text='Рост (см):')
        elif 'm' in u:
            self.h_label.config(text='Рост (м):')
        else:
            self.h_label.config(text='Рост (ft/in):')

    def calculate_bmi(self):
        try:
            weight = float(self.weight_var.get())
            height = float(self.height_var.get())
            unit = self.unit_var.get()

            # convert to meters and kg
            if unit == 'Metric (m, kg)':
                h_m = height
                w_kg = weight
            elif unit == 'Metric (cm, kg)':
                h_m = height / 100.0
                w_kg = weight
            else:  # Imperial
                # expect input height as feet.inches where user writes e.g. 5.11 (5 ft 11 in)
                # or user could type total inches; support both
                if '.' in str(height):
                    parts = str(height).split('.')
                    ft = float(parts[0])
                    inch = float(parts[1])
                    # if user typed .11 meaning 11 inches
                    h_m = (ft * 0.3048) + (inch * 0.0254)
                else:
                    # treat as inches
                    h_m = float(height) * 0.0254
                w_kg = float(weight) * 0.45359237

            if h_m <= 0:
                raise ValueError('Рост должен быть больше нуля')
            bmi = w_kg / (h_m * h_m)
            bmi = round(bmi, 2)
            self.imt_value.set(bmi)
            category = bmi_category(bmi)
            recom = pretty_bmi_recommendation(category)
            self._update_result_text(bmi, category, recom)
            self._draw_canvas(bmi)
        except Exception as e:
            messagebox.showerror('Ошибка', f'Не удалось рассчитать ИМТ: {e}')

    def _update_result_text(self, bmi, category, recom):
        self.result_text.config(state='normal')
        self.result_text.delete('1.0', 'end')
        self.result_text.insert('1.0', f'ИМТ: {bmi}\nКатегория: {category}\n\n{recom}')
        self.result_text.config(state='disabled')

    def _draw_canvas(self, bmi):
        # draw a horizontal bar with colored segments and a marker
        c = self.canvas
        c.delete('all')
        width = int(c.winfo_width() or 400)
        height = int(c.winfo_height() or 300)
        padding = 40
        bar_y = height // 2
        bar_h = 40
        bar_x0 = padding
        bar_x1 = width - padding
        total_w = bar_x1 - bar_x0

        # segments thresholds in BMI: [0-16,16-18.5,18.5-25,25-30,30-35,35-40,40+]
        thresholds = [0, 16, 18.5, 25, 30, 35, 40, 60]
        colors = ['#4c77ff', '#6fb3ff', '#66c566', '#ffd36b', '#ffb36b', '#ff8c6b', '#ff6b6b']

        # draw segments
        for i in range(len(thresholds)-1):
            lo = thresholds[i]
            hi = thresholds[i+1]
            frac_lo = (lo - thresholds[0]) / (thresholds[-1] - thresholds[0])
            frac_hi = (hi - thresholds[0]) / (thresholds[-1] - thresholds[0])
            x0 = bar_x0 + frac_lo * total_w
            x1 = bar_x0 + frac_hi * total_w
            c.create_rectangle(x0, bar_y - bar_h/2, x1, bar_y + bar_h/2, fill=colors[i], outline='')

        # draw ticks and labels
        for t in [16, 18.5, 25, 30, 35, 40]:
            frac = (t - thresholds[0]) / (thresholds[-1] - thresholds[0])
            x = bar_x0 + frac * total_w
            c.create_line(x, bar_y - bar_h/2 - 6, x, bar_y + bar_h/2 + 6)
            c.create_text(x, bar_y + bar_h/2 + 18, text=str(t), font=('Arial', 9))

        # marker for bmi
        if bmi and bmi > 0:
            # clamp within displayable range
            display_bmi = clamp(bmi, thresholds[0], thresholds[-1])
            frac = (display_bmi - thresholds[0]) / (thresholds[-1] - thresholds[0])
            mx = bar_x0 + frac * total_w
            # draw triangle marker
            c.create_polygon(mx-8, bar_y - bar_h/2 - 12, mx+8, bar_y - bar_h/2 - 12, mx, bar_y - bar_h/2 - 2, fill='black')
            c.create_text(mx, bar_y - bar_h/2 - 24, text=f'{bmi}', font=('Arial', 10, 'bold'))

        # small legend
        c.create_text(width//2, height - 16, text='ИМТ шкала — чем выше, тем больше риск для здоровья', font=('Arial', 9))

    def save_config(self):
        data = self._gather_data()
        if data is None:
            return
        # save to JSON file and optionally to DB
        filename = filedialog.asksaveasfilename(defaultextension='.json', filetypes=[('JSON files', '*.json')], initialdir=CONFIG_DIR)
        if not filename:
            return
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        # save to DB if logged in
        if self.user_id:
            name = os.path.basename(filename)
            self.app.db.save_profile(self.user_id, name, data)
        messagebox.showinfo('Сохранено', f'Конфигурация сохранена: {filename}')

    def load_config(self):
        fn = filedialog.askopenfilename(filetypes=[('JSON files', '*.json')], initialdir=CONFIG_DIR)
        if not fn:
            return
        try:
            with open(fn, 'r', encoding='utf-8') as f:
                data = json.load(f)
            self._apply_data(data)
            messagebox.showinfo('Готово', 'Конфигурация загружена')
        except Exception as e:
            messagebox.showerror('Ошибка', f'Не удалось загрузить конфигурацию: {e}')

    def export_report(self):
        bmi = self.imt_value.get()
        data = self._gather_data(save_partial=True)
        if data is None:
            return
        category = bmi_category(bmi) if bmi > 0 else '—'
        recom = pretty_bmi_recommendation(category)
        report_lines = []
        report_lines.append('FitPulse — Отчёт ИМТ')
        report_lines.append(f'Дата: {datetime.utcnow().isoformat()}')
        if self.username:
            report_lines.append(f'Пользователь: {self.username}')
        report_lines.append('---')
        report_lines.append(f"Пол: {data.get('gender')}")
        report_lines.append(f"Возраст: {data.get('age')}")
        report_lines.append(f"Единицы: {data.get('units')}")
        report_lines.append(f"Рост (в исходных единицах): {data.get('height')}")
        report_lines.append(f"Вес (в исходных единицах): {data.get('weight')}")
        report_lines.append(f"ИМТ: {bmi}")
        report_lines.append(f"Категория: {category}")
        report_lines.append('')
        report_lines.append('Рекомендации:')
        report_lines.append(recom)

        fn = filedialog.asksaveasfilename(defaultextension='.txt', filetypes=[('Text files', '*.txt')], initialdir=REPORTS_DIR)
        if not fn:
            return
        with open(fn, 'w', encoding='utf-8') as f:
            f.write('\n'.join(report_lines))
        messagebox.showinfo('Экспортировано', f'Отчёт сохранён: {fn}')

    def _gather_data(self, save_partial=False):
        try:
            units = self.unit_var.get()
            gender = self.gender_var.get()
            age = int(self.age_var.get())
            height = float(self.height_var.get())
            weight = float(self.weight_var.get())
            bmi = float(self.imt_value.get()) if self.imt_value.get() else 0.0
            data = {
                'units': units,
                'gender': gender,
                'age': age,
                'height': height,
                'weight': weight,
                'bmi': bmi,
                'saved_at': datetime.utcnow().isoformat()
            }
            return data
        except Exception as e:
            if save_partial:
                return None
            messagebox.showerror('Ошибка', f'Проверьте введённые данные: {e}')
            return None

    def _apply_data(self, data):
        # apply JSON-loaded data to UI
        try:
            self.unit_var.set(data.get('units', self.unit_var.get()))
            self.gender_var.set(data.get('gender', self.gender_var.get()))
            self.age_var.set(data.get('age', self.age_var.get()))
            self.height_var.set(data.get('height', self.height_var.get()))
            self.weight_var.set(data.get('weight', self.weight_var.get()))
            if 'bmi' in data:
                self.imt_value.set(data.get('bmi', 0.0))
                self._update_result_text(data.get('bmi', 0.0), bmi_category(data.get('bmi', 0.0)), pretty_bmi_recommendation(bmi_category(data.get('bmi', 0.0))))
                self._draw_canvas(data.get('bmi', 0.0))
        except Exception as e:
            messagebox.showerror('Ошибка', f'Не удалось применить данные: {e}')

    def _on_logout(self):
        confirm = messagebox.askyesno('Выйти', 'Вы уверены, что хотите выйти из аккаунта?')
        if confirm:
            self.app.logout()

    def on_login(self, user_id, username):
        self.user_id = user_id
        self.username = username

    def on_logout(self):
        self.user_id = None
        self.username = None

# -----------------------------
# Run application
# -----------------------------
if __name__ == '__main__':
    app = fatburnApp()
    app.mainloop()

# -----------------------------------------------
# End of file
# -----------------------------------------------
